
// @(#)$Id: ListIterator.spec 1299 2005-03-01 18:58:45Z erikpoll $

// Copyright (C) 2001, 2004 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.


package java.util;

/** JML's specification of java.util.Iterator.
 * Some of this specification is taken from ESC/Java.
 * @version $Revision: 1299 $
 * @author Gary T. Leavens
 * @author Daniel M. Zimmerman
 * @author Wenhao Lu
 */
public interface ListIterator<E> extends Iterator<E> {
	/*
	 * underlyingCollection and modCount ensure that the listIterator is still valid
	 * when the operation is being called.
	 */
	//@ public instance ghost Collection<E> underlyingCollection;
    //@ public instance ghost int modCount;
    
    //@ model instance int cursor_position; in objectState;

    //@ public instance invariant 0 <= cursor_position;
	
	//-ESC@ public represents hasPrevElements = hasPrevious(); // FIXME - does this recursive definition work for RAC?
	//-ESC@ public represents nextElement = next(); // FIXME - does this recursive definition work for RAC?


	//specs inherited from Iterator
	boolean hasNext();
		
    E next();

    /*@ public behavior
    @	  requires concurrentModificationsAllowed || underlyingCollection.modCount == expectedModCount;
    @	  ensures \result <==> (cursor_position > 0);
    @ also 
    @	  public exceptional_behavior
    @   requires !concurrentModificationsAllowed && underlyingCollection.modCount != expectedModCount;
    @   signals_only ConcurrentModificationException;
    @*/
    boolean hasPrevious();

    /*@ public behavior
    @	  requires concurrentModificationsAllowed || underlyingCollection.modCount == expectedModCount;
    @	  requires hasPrevElements;
    @     ensures !remove_called_since;
    @     ensures !returnsNull ==> (\result != null);	  
    @ also 
    @	public exceptional_behavior
    @   	requires !concurrentModificationsAllowed && underlyingCollection.modCount != expectedModCount;
    @   	signals_only ConcurrentModificationException;
    @ also
    @   public exceptional_behavior
    @   	requires !hasPrevElements;
    @   	assignable \nothing;
    @   	signals_only NoSuchElementException;
    @*/
    E previous();

    /*@ public behavior
    @	  requires concurrentModificationsAllowed || underlyingCollection.modCount == expectedModCount;
    @	  ensures \result == cursor_position;
    @ also 
    @	  public exceptional_behavior
    @   requires !concurrentModificationsAllowed && underlyingCollection.modCount != expectedModCount;
    @   signals_only ConcurrentModificationException;
    @*/
    int nextIndex();

    /*@ public behavior
    @	  requires concurrentModificationsAllowed || underlyingCollection.modCount == expectedModCount;
    @	  ensures \result == cursor_position - 1;
    @ also 
    @	  public exceptional_behavior
    @   requires !concurrentModificationsAllowed && underlyingCollection.modCount != expectedModCount;
    @   signals_only ConcurrentModificationException;
    @*/
    
    int previousIndex();


    // Modification Operations
    void remove();

    /*@ public behavior
    @	  requires concurrentModificationsAllowed || underlyingCollection.modCount == expectedModCount;
    @	  ensures expectedModCount == underlyingCollection.modCount;
    @ also 
    @	  public exceptional_behavior
    @   requires !concurrentModificationsAllowed && underlyingCollection.modCount != expectedModCount;
    @   signals_only ConcurrentModificationException;
    @*/
    void set(E o);

    /*@ public behavior
    @	  requires modCount == underlyingCollection.modCount;
    @	  ensures modCount == underlyingCollection.modCount;
    @	  FIXME - behavior is not fully specified here
    @   signals_only RuntimeException;
      @   signals (UnsupportedOperationException);
    @*/
    void add(E o);
}
