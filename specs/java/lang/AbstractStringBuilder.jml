package java.lang;
//@ non_null_by_default // NOTE: This is not publicly visible
abstract class AbstractStringBuilder implements Appendable,CharSequence {
    /*@ spec_public */
    byte[] value; //@ in _value;
    /*@ spec_public */
    int count; //@ in _value;
    
 // FIXME - should we use charArray instead of accumulatedString?
    // FIXME - we don't need both

    //@ model public non_null String accumulatedString;

    //@ model public \bigint capacity;
    
    // Present in some but not all Java builds
    //private static final int MAX_ARRAY_SIZE;

    //@ normal_behavior
    //@   ensures true;
    //@ pure
    AbstractStringBuilder();
    //@ normal_behavior
    //@   ensures true;
    //@ pure
    AbstractStringBuilder(int size);
//    public int length();
    
    //@ ensures \result == capacity;
    //@ pure
    public int capacity();
//    public void ensureCapacity(int);
//    private void ensureCapacityInternal(int);
//    private int newCapacity(int);
//    private int hugeCapacity(int);
//    public void trimToSize();
//    public void setLength(int);
//    public char charAt(int);
//    public int codePointAt(int);
//    public int codePointBefore(int);
//    public int codePointCount(int, int);
//    public int offsetByCodePoints(int, int);

    /*@ public normal_behavior
      @   requires 0 <= srcBegin && srcBegin <= srcEnd;
      @   requires srcEnd <= accumulatedString.length();
      @   requires 0 <= dstBegin && dstBegin + srcEnd - srcBegin <= dst.length;
      @   assignable dst[dstBegin .. dstBegin+srcEnd-srcBegin];
      @   //-RAC@ ensures CharSequence.equal(accumulatedString.charArray,srcBegin,
        //-RAC@                  dst,dstBegin,srcEnd-srcBegin);
      @*/
    public synchronized void getChars(int srcBegin, int srcEnd,
                                    char[] dst, int dstBegin);
    
    /*@ public normal_behavior
    @   requires 0 <= index < accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,index)
    @                        + ch + accumulatedString.substring(index+1)));
    @ implies_that
    @ public normal_behavior
    @   requires 0 <= index < accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString.length()
    @           == \old(accumulatedString.length())
    @        && (\forall int i; 0 <= i < accumulatedString.length()
    @                                  && i != index;
    @                           accumulatedString.charAt(i)
    @                           == \old(accumulatedString.charAt(i)))
    @        && accumulatedString.charAt(index) == ch;
    @*/
    public void setCharAt(int index, char ch);
    
    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + o._value *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(/*@ nullable */Object o);
    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + s *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(String s);
    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + s *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(StringBuffer s);
//    AbstractStringBuilder append(AbstractStringBuilder);

    //@ also public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + c *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(CharSequence c);

    //@ private normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    private AbstractStringBuilder appendNull();

    //@ also public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    @Override
    public AbstractStringBuilder append(CharSequence c, int offset, int length);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(char[] ca);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(char[]ca, int offset, int length);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + s *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(boolean b);
    
    //@ also public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(char x);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(int x);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(long x);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(float f);

    //@ public normal_behavior
    //@   assignable _value;
    //@   ensures (* _value == \old(_value) + x *);
    //@   ensures \result == this;
    public AbstractStringBuilder append(double d);
    
//    public AbstractStringBuilder delete(int, int);
//    public AbstractStringBuilder appendCodePoint(int);
    
    /*@ public normal_behavior
      @   requires 0 <= index < accumulatedString.length();
      @   assignable accumulatedString;
      @   ensures accumulatedString.subSequence(0,index).equals(
      @                  \old(accumulatedString.subSequence(0,index)));
      @   ensures
      @       accumulatedString.subSequence(index,accumulatedString.length()).equals(
      @       \old(accumulatedString.subSequence(index+1,accumulatedString.length())));
      @   ensures accumulatedString.length() == \old(accumulatedString.length()-1);
      @   ensures \result == this;
      @*/

    public AbstractStringBuilder deleteCharAt(int index);
//    public AbstractStringBuilder replace(int, int, String);
//    public String substring(int);
//    public CharSequence subSequence(int, int);
//    public String substring(int, int);

    /*@ public normal_behavior
    @   requires 0 <= offset <= accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,offset)
    @                        + c + accumulatedString.substring(offset)));
    @   ensures \result == this;   
    @*/
    public synchronized AbstractStringBuilder insert(int offset, char c);

    /*@ public normal_behavior
      @   requires 0 <= offset <= accumulatedString.length();
      @   assignable accumulatedString;
      @   ensures accumulatedString
      @           .equals(\old(accumulatedString.substring(0,offset)
      @                        + i + accumulatedString.substring(offset)));
      @   ensures \result == this;   
      @*/
    public AbstractStringBuilder insert(int offset, int i);

    /*@ public normal_behavior
      @   requires 0 <= offset <= accumulatedString.length();
      @   assignable accumulatedString;
      @   ensures accumulatedString
      @           .equals(\old(accumulatedString.substring(0,offset)
      @             + String.valueOf(l) + accumulatedString.substring(offset)));
      @   ensures \result == this;   
      @*/
    public AbstractStringBuilder insert(int offset, long l);

  /*@ public normal_behavior
    @   requires 0 <= offset <= accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,offset)
    @                        + String.valueOf(str)
    @                        + accumulatedString.substring(offset)));
    @   ensures \result == this;   
    @*/
    public synchronized AbstractStringBuilder insert(int offset, char[] str);

  /*@  public normal_behavior
    @   requires 0 <= offset <= accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,offset)
    @                        + b + accumulatedString.substring(offset)));
    @   ensures \result == this;   
    @*/
    public AbstractStringBuilder insert(int offset, boolean b);

  /*@ public normal_behavior
    @   requires 0 <= offset <= accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,offset)
    @                        + obj + accumulatedString.substring(offset)));
    @   ensures \result == this;   
    @*/
    public synchronized AbstractStringBuilder insert(int offset, Object obj);

  /*@ public normal_behavior
    @   requires 0 <= offset <= accumulatedString.length();
    @   assignable accumulatedString;
    @   ensures accumulatedString
    @           .equals(\old(accumulatedString.substring(0,offset)
    @                        + str + accumulatedString.substring(offset)));
    @   ensures \result == this;   
    @*/
    public synchronized AbstractStringBuilder insert(int offset, String str);

    /*@ public normal_behavior
      @   requires 0 <= offset <= accumulatedString.length();
      @   assignable accumulatedString;
      @   ensures accumulatedString
      @           .equals(\old(accumulatedString.substring(0,offset)
      @                        + f + accumulatedString.substring(offset)));
      @   ensures \result == this;   
      @*/
    public AbstractStringBuilder insert(int offset, float f);
    
    /*@ public normal_behavior
      @   requires 0 <= offset <= accumulatedString.length();
      @   assignable accumulatedString;
      @   ensures accumulatedString
      @           .equals(\old(accumulatedString.substring(0,offset)
      @                        + d + accumulatedString.substring(offset)));
      @   ensures \result == this;   
      @*/
    public AbstractStringBuilder insert(int offset, double d);

//    public int indexOf(String);
//    public int indexOf(String, int);
//    public int lastIndexOf(String);
//    public int lastIndexOf(String, int);
    
    /*@ public normal_behavior
      @    assignable accumulatedString;
      @    ensures \result == this;
      @    ensures accumulatedString.length() == \old( accumulatedString.length() );
      @    ensures (\forall int i; 0<=i && i<accumulatedString.length();
                          \old(charAt(i)) == charAt(length()-1-i));
      @*/
    public AbstractStringBuilder reverse();
    
//    private void reverseAllValidSurrogatePairs();
//    public abstract String toString();
//    final char[] getValue();
//    public Appendable append(char) throws java.io.IOException;
//    public Appendable append(CharSequence, int, int) throws java.io.IOException;
//    public Appendable append(CharSequence) throws java.io.IOException;
    
    
}
