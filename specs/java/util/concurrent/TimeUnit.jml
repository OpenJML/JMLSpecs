package java.util.concurrent;
// SInce 1.5

//@ immutable
public enum TimeUnit { // FIXME - change to enum?
     NANOSECONDS,
     MICROSECONDS,
     MILLISECONDS,
     SECONDS,
     MINUTES,
     HOURS,
     DAYS;

    //@ model public long _scale;
    //@ public final static invariant NANOSECONDS._scale == 1L;
    //@ public final static invariant MICROSECONDS._scale == 1000L;
    //@ public final static invariant MILLISECONDS._scale == 1000L * 1000L;
    //@ public final static invariant SECONDS._scale == 1000L * 1000L * 1000L;
    //@ public final static invariant MINUTES._scale == 1000L * 1000L * 1000L * 60L;
    //@ public final static invariant HOURS._scale == 1000L * 1000L * 1000L * 60L * 60L;
    //@ public final static invariant DAYS._scale == 1000L * 1000L * 1000L * 60L * 60L * 24L;
    
    //@ public final invariant this._scale >= 1L;
  
    // Converts t units of TimeUnit u into the result expressed ain the receiver's unit
    // Relies on the fact that the scale values are multiples of each other
  //@ public normal_behavior
  //@  requires u._scale <= this._scale;
  //@  ensures \result == t / (this._scale / u._scale);
  //@ also public normal_behavior
  //@  requires u._scale > this._scale && t <= Long.MAX_VALUE / (u._scale / this._scale) && t >= Long.MIN_VALUE / (u._scale / this._scale);
  //@  ensures \result == t * (u._scale / this._scale);
  //@ also public normal_behavior
  //@  requires u._scale > this._scale && t > Long.MAX_VALUE / (u._scale / this._scale);
  //@  ensures \result == Long.MAX_VALUE;
  //@ also public normal_behavior
  //@  requires u._scale > this._scale && t < Long.MIN_VALUE / (u._scale / this._scale);
  //@  ensures \result == Long.MIN_VALUE;
  //@ pure function
  public long convert(long t, TimeUnit u);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / NANOSECONDS._scale;
  //@ pure function
  public long toNanos(long t);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / MICROSECONDS._scale;
  //@ pure function
  public long toMicros(long t);
  
  //@ public normal_behavior
  //@   requires this._scale >= MILLISECONDS._scale;
  //@   requires t <= Long.MAX_VALUE/(this._scale / MILLISECONDS._scale);
  //@   ensures \result == t * (this._scale / MILLISECONDS._scale);
  //@ also public normal_behavior
  //@   requires this._scale < MILLISECONDS._scale;
  //@   ensures \result == t / (MILLISECONDS._scale / this._scale);
  
  //@ pure function
  public long toMillis(long t);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / SECONDS._scale;
  //@ pure function
  public long toSeconds(long t);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / MINUTES._scale;
  //@ pure function
  public long toMinutes(long t);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / HOURS._scale;
  //@ pure function
  public long toHours(long t);
  
  //@ public normal_behavior
  //@  requires t <= Long.MAX_VALUE/scale;
  //@  ensures \result == t * this._scale / DAYS._scale;
  //@ pure function
  public long toDays(long t);

//  abstract int excessNanos(long t1, long t2);
 // public void timedWait(java.lang.Object, long) throws java.lang.InterruptedException;
//  public void timedJoin(java.lang.Thread, long) throws java.lang.InterruptedException;
//  public void sleep(long) throws java.lang.InterruptedException;
// FIXME  TimeUnit(java.lang.String, int, TimeUnit$1);

//  static {};
}
