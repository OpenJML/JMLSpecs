package org.jmlspecs.lang;

//@ immutable pure
public class seq<T> implements IJmlPrimitiveType, IJmlIntArrayLike {
 /*@   
    axiom \forall seq<T> s, ss;; s == ss <==> (s.length == ss.length && \forall int i; 0<=i<s.length; s[i] == ss[i]);

    model public \bigint length;
    public invariant length >= 0;
    
    public normal_behavior
      ensures \result == length;
    model function public \bigint size();
    
    public normal_behavior
      ensures \result == this[i];
    model function public T get(\bigint i);

    public normal_behavior
      ensures \result == (length == 0);
    model function public boolean isEmpty();
    
    public normal_behavior
      ensures \result.length == 0;
    model function static public <T> seq<T> empty();
    
    public normal_behavior
      ensures \result.length == 1;
      ensures \result[0] == t;
    model function static public <T> seq<T> of(T t);
    
    public normal_behavior
       ensures \result == (s.length == ss.length && (\forall \bigint i;; (0 <= i < s.length) ==> (s[i] == ss[i]) ));
    model function public static <T> boolean equals(seq<T> s, seq<T> ss);
    
    public normal_behavior
       ensures \result == (this == s || equals(this,s));
    model function public boolean equals(seq<T> s);
    
    public normal_behavior
      requires 0 <= j <= this.length;
      ensures \result.length == 1 + this.length;
      ensures (\forall \bigint i;; (0 <= i < j) ==> (\result[i] == this[i]));
      ensures (\forall \bigint i;; (j < i <= this.length) ==> (\result[i] == this[i-1]));
      ensures \result[j] == v;
    model function public seq<T> add(\bigint j, T v);

    public normal_behavior
      ensures \result.length == 1 + this.length; // FIXME - needed to prove valuetypes Seq.addBumpsSize, but why?
      ensures \result == add(length,v);
    model function public seq<T> add(T v);

    public normal_behavior
      ensures \result.length == this.length + s.length;
      ensures (\forall \bigint i;; (0 <= i && i < this.length) ==> (\result[i] == this[i]));
      ensures (\forall \bigint i;; (this.length <= i && i < \result.length) ==> (\result[i] == this[i-this.length]));
    model function public seq<T> append(seq<T> s);

    public normal_behavior
      ensures \result.length == this.length + 1;
      ensures (\forall \bigint i;; (0 <= i < this.length) ==> (\result[i+1] == this[i]));
      ensures \result[0] == t;
    model function public seq<T> prepend(T t);

    public normal_behavior
      requires 0 <= j && j < this.length;
      ensures \result.size() == this.length - 1;
      ensures (\forall \bigint i;; (0 <= i && i < j) ==> (\result[i] == this[i]));
      ensures (\forall \bigint i;; (j <= i && i < \result.length) ==> (\result[i] == this[i+1]));
    model function public seq<T> remove(\bigint j);

    public normal_behavior
        ensures \result.length == this.length;
        ensures \result[i] == c;
        ensures \forall \bigint j; j != i; \result[j] == this[j];
        ensures this[i] == c ==> \result == this;
    model function public seq<T> put(\bigint i, T c);

    public normal_behavior
        ensures \result.length == j-i;
        ensures \forall \bigint k; 0<=k<j-i; \result[k] == this[k+i];
    model function public seq<T> sub(\bigint i, \bigint j);


    @*/
}

